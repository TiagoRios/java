package com.revisoes.genericos;

import java.util.logging.Logger;

/**
 * <p>
 * Classe de exemplo que mostra o acontece depois do compilador aplicar o
 * apagamento de tipo.
 * </p>
 * 
 * Tipo ilimitado é transformado em Object, exemplos:
 * <blockquote>
 * 
 * <pre>{@code <T>} transformado em Object.</pre>
 * 
 * <pre>{@code <?>} transformado em Object.</pre>
 * 
 * </blockquote>
 * 
 * Tipo limitado é transformado em seu limite mais amplo, exemplos:
 * 
 * <blockquote>
 * 
 * <pre>{@code <? super Number>} transformado em Object.</pre>
 * 
 * <pre>{@code <Object super Integer>} transformado em Object.</pre>
 * 
 * <pre>{@code <? extends Number>} transformado em Number.</pre>
 * 
 * <pre>{@code <Short extends Number>} transformado em Number.</pre>
 * 
 * </blockquote>
 */
public class ExclusaoDeTipo {
    static Logger logger = Logger.getLogger(ExclusaoDeTipo.class.getName());

    /**
     * Depois que é aplicado o apagamento de tipo da classe genérica, toda a classe
     * é transformada em:
     * <blockquote>
     * 
     * <pre>
     * public static class Node {
     * 
     *     public Object data;
     * 
     *     public Node(Object data) {
     *         this.data = data;
     *     }
     * 
     *     public void setData(Object data) {
     *         System.out.println("Node.setData");
     *         this.data = data;
     *     }
     * }
     * </pre>
     * 
     * </blockquote>
     */
    public static class Node<T> {

        public T data;

        public Node(T data) {
            this.data = data;
        }

        public void setData(T data) {
            System.out.println("Node.setData");
            this.data = data;
        }
    }

    /**
     * Depois que é aplicado o apagamento de tipo da classe genérica, toda a classe
     * é transformada em:
     * <blockquote>
     * 
     * <pre>
     * public class Node2 {
     * 
     *     private Comparable data;
     *     private Node next;
     * 
     *     public Node2(Comparable data, Node next) {
     *         this.data = data;
     *         this.next = next;
     *     }
     * 
     *     public Comparable getData() {
     *         return data;
     *     }
     * 
     *     public Node getNode() {
     *         return next;
     *     }
     * }
     * </pre>
     * 
     * </blockquote>
     */
    public class Node2<T extends Comparable<T>> {

        private T data;
        private Node<T> next;

        public Node2(T data, Node<T> next) {
            this.data = data;
            this.next = next;
        }

        public T getData() {
            return data;
        }

        public Node<T> getNode() {
            return next;
        }
    }

    /**
     * O compilador gera um método de ponte (Bridge method)
     */
    public static class MyNode extends Node<Integer> {
        public MyNode(Integer data) {
            super(data);
        }

        // Bridge method generated by the compiler
        // public void setData(Object data) {
        // setData((Integer) data);
        // }

        public void setData(Integer data) {
            System.out.println("MyNode.setData");
            super.setData(data);
        }
    }

    public static void main(String... args) {
        
        try {
            MyNode myNode = new MyNode(12345); // it's a integer, not a String.
            // parametrizei para o compilador não gerar avisos.
            Node<Integer> node = myNode; // Comente-o para gerar o erro.
            // Node node = myNode; // A raw type - compiler throws an unchecked warning

            node.setData(999); // Comente-o para gerar o erro.
            // node.setData("Hello"); // Com Strings Causes a ClassCastException to be
            // thrown.

            logger.info("Data = " + myNode.data.toString());
        } catch (Exception e) {
            logger.severe("\n\n" + e.getMessage() + "\n\n");
        }
    }
}
